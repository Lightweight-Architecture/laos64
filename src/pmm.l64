/*
 * MIT License
 *
 * Copyright (c) 2026 cr4zyengineer
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 */

section .data
    pmm_suc db "initilization succeeded\n\0"
    pmm_mem db "memory size:\0"
    pmm_img db "image size:\0"
    pmm_page db "page size:\0"
    pmm_page2 db "pages:\0"
    pmm_master db "master page ptr:\0"
    pmm_usable db "usable pages ptr:\0"
    pmm_mark db "have to mark pages as in use:\0"
    pmm_size_hex db " 0x\0"
    pmm_suffix db "[pmm] \0"

section .bss
    pmm_init_once 1                                 ; once initilizer boolean
    pmm_master_ptr 8                                ; address that points at the main page
    pmm_max_pages 8                                 ; count of pages

%define% PAGE_SIZE 0x2000                           ; 8K pages

_pmm_log:
    bl _puts, pmm_suffix
    bl _puts
    ret

_pmm_size_log:
    bl _pmm_log
    bl _puts, pmm_size_hex
    bl _putbase, r1, 16
    bl _putc, '('
    bl _putbase, r1, 10
    bl _putc, ')'
    bl _putc, '\n'
    ret

_pmm_page_addr:
    mul rr, r0, PAGE_SIZE                           ; page number by size equals address
    ret

_pmm_addr_page:
    clr rr                                          ; clearing return register to return NULL on failure
    jz r0, .end
    div rr, r0, PAGE_SIZE                           ; page number by size equals address
.end:
    ret

_pmm_page_get:
    clr r1, r2
    jz r0, .do_get
.page_not_null:
    div r1, r0, 8                                   ; byte index
    mod r2, r0, 8                                   ; bit index
.do_get:
    ldq r4, pmm_master_ptr
    add r1, r4
    ldb r3, r1
    shr r3, r2
    and rr, r3, 1
    ret

_pmm_page_set:
    clr r2, r3
    jz r0, .do_set
.page_not_null:
    div r2, r0, 8                                   ; byte index
    mod r3, r0, 8                                   ; bit index
.do_set:
    ldq r6, pmm_master_ptr
    add r2, r6
    ldb r4, r2
    mov r5, 1
    shl r5, r3
    not r5
    and r4, r5
    shl r1, r3
    or r4, r1
    stb r2, r4
    ret

_pmm_alloc:
    clr r0
    ldq r1, pmm_max_pages
.loop:
    bl _pmm_page_get, r0
    jz rr, .got_page
    cmp r0, r1
    jgt .no_free_pages
    inc r0
    jmp .loop
.got_page:
    bl _pmm_page_set, r0, 0x1
    bl _pmm_page_addr, r0
    ret
.no_free_pages:
    clr rr
    ret

_pmm_free:
    bl _pmm_addr_page
    ldq r0, pmm_max_pages
    cmp rr, r0
    jgt .end
    bl _pmm_page_set, rr, 0
.end:
    ret

_pmm_init:
    ldb r0, pmm_init_once                           ; get once initilizer boolean value
    jnz r0, .return                                 ; if its initilized return early
    bl _get_mem_size                                ; asking memory controller nicely to say how large it is
    mov r0, rr                                      ; moving result to safe location
    bl _pmm_size_log, pmm_mem, r0                   ; outputting memory size
    mov r1, __la64_exec_img_end                     ; set r1 to assembler internal img size label
    bl _pmm_size_log, pmm_img, r1                   ; output image size
    bl _pmm_size_log, pmm_page, PAGE_SIZE           ; outputting page size
    div r0, PAGE_SIZE                               ; calculating how many pages fit into address space
    stq pmm_max_pages, r0                           ; store count of maximum pages
    bl _pmm_size_log, pmm_page2, r0                 ; output how many pages fit into address space
    add r1, 0x1FFF                                  ; add constants division to the assembler FRIDAAA!!! ahhh
    div r1, PAGE_SIZE                               ; get the number of pages the image is sized
    bl _pmm_page_addr, r1                           ; get end address of image
    mov r2, rr                                      ; store page end address of image into safe location
    stq pmm_master_ptr, r2                          ; store address so the pointer points to master page(s)
    bl _pmm_size_log, pmm_master, r2                ; output address of pmm master page
    div r3, r0, 8                                   ; calculating memory size but in pages
    add r3, r2                                      ; adding master page pointer to offset
    add r3, 0x1FFF                                  ; adding page size - 1 (FRIDA ADD MATH OPS FOR CONSTANTS AT ASSEMBLING TIME)
    div r3, PAGE_SIZE                               ; do ceiling calculating
    bl _pmm_page_addr, r3                           ; get page address
    mov r3, rr                                      ; here we go, knowing the address of the first usable page
    bl _pmm_size_log, pmm_usable, r3                ; outputting usable pointer that doesnt really exist
    div r3, PAGE_SIZE                               ; division through page size
    bl _pmm_size_log, pmm_mark, r3                  ; know we know how many pages from start to end we have to mark as used
.loop:
    dec r3
    bl _pmm_page_set, r3, 0x1                       ; mark page as used
    jnz r3, .loop
.end:
    bl _pmm_log, pmm_suc                            ; page memory start
    stb pmm_init_once, 1                            ; mark as initilized
.return:
    ret
